# 宏
## 简单的宏
### 定义
[#define 指令 （简单的宏）]   #define 标识符 替换列表

替换列表是一系列的C语言记号，包括标识符、关键字、数、字符常量、字符串字面量、运算符和标点符号。当预处理器遇到一个宏定义时，会做一个“标识符”代表“替换列表”的记录。在文件后面的内容中，不管标识符在任何位置出现，预处理器都会替代列表代替它。
* 不要在宏定义中出现任何额外的符号，否则它们会被作为替换列表的一部分。
简单的宏主要用来定义“明示常量”。使用宏，我们可以给数值、字符串和字符命名。
```sh
#define STE_LEN 80
#define TRUE    1
#define FALSE   0
#define PI      3.14159
#define CR      '\r'
#define EOS     '\0'
```

### 宏优点

1. **程序更易读。**
1. **程序更易改。**
1. **可以帮助避免前后不一致或键盘输入错误。**
1. **可以对C语法做小修改。**
1. **对类型重命名。**
1. **控制条件编译。**

## 带参数的宏
### 定义
[#define指令——带参数的宏]  #define 标识符（x1,x2,...,xn) 替换列表    其中x1，x2,...,xn是标识符（宏的参数）。
* 再宏的名字和左括号之间必须没有空格。如果有空格，预处理器会认为实在定义一个简单的宏，其中（x1,x2,...,xn)是替换列表的一部分。
### 优点
1. **程序可能会稍微快一些。**
1. **宏会更“通用”。** 与函数的参数不同，宏的参数没有类型。因此，只要预处理后的程序依然是合法的，宏可以接受任何类型的参数。
1. **编译后的代码通常会变大。** 每一处宏调用都会导致插入的宏的替换列表，由此导致程序的源代码增加。宏使用的越频繁，这种效果越明显。当宏调用嵌套时，这个问题会互相叠加从而使程序更加复杂。
1. **宏参数没有类型检查。**
1. **无法用一个指针来指向一个宏。**
1. **宏可能会不止一次地计算它的参数。**
* 由于多次计算宏的参数而导致的错误可能非常难于发现，因为宏调用和函数调用看起来是一样的。更糟糕的是，这类宏可能再大多数情况下正常工作，仅在特定参数有副作用时失效。

## #运算符

宏定义可以包含两个运算符：#和##。编译器不会识别这两种运算符，相反，它们会在预处理时被执行。
#运算符将一个宏的参数转换为字符串字面量。它仅允许出现在带参数的宏的替换列表中。#运算符有大量的用途，这里只来讨论其中的一种。假设我们决定再调用过程中使用PRINT_INT宏作为一个便捷的方法，来输出一个整型变量或表达式的值。#运算符可以使PRINT_INT为每个输出的值添加标签。下面是改进后的PRINT_INT：
#define PRINT_INT(x) printf(#x " = %d\n", x)     x之前的#运算符通知预处理器根据PRINT_INT的参数创建一个字符串字面量。因此，调用PRINT_INT(i/j);会变成printf("i/j" " =  %d\n", i/j);  在C语言中相邻的字符串字面量会被合并，因此上边的语句等价与：printf("i/j =  %d\n", i/j);

## ##运算符

##运算符可以将两个记号（例如标识符）“粘”在一起，成为一个记号。如果其中一个是宏参数，“粘合”会在当形式参数被相应的实际参数替换后发生。考虑下面的宏#define MK_ID(n) i##n     当MK_ID被调用时（比如MK_ID(1)），预处理器首先使用自变量（这个例子是1）替换参数n。接着预处理器将i和1链接成一个记号
（i1）。下面的声明使用MK_ID创建了3个标识符：int MK_ID(1),MK_ID(2),MK_ID(3);  预处理后声明变为：int i1,i2,i3;

## 宏的通用属性
宏要遵守的规则：
* **宏的替换列表可以包含对另一个宏的调用。**
```sh
#define PI 3.14159
#define TWO_PI (2 * PI)
```
* **预处理器只会替换完整的记号，而不会替换记号片段。** 因此，预处理器会忽略嵌在标识符、字符常量、字符串字面量之中的宏名。
```sh
#define SIZE 256
int BUFFER_SIZE;
if (BUFFER_SIZE > SIZE)
  puts("Error : SIZE exceeded");
预处理后，这些代码会变成为：
int BUFFER_SIZE;
if (BUFFER_SIZE > 256)
  puts ("Error : SIZE exceeded");
 标识符BUFFER_SIZE和字符串"Error: SIZE exceeded"没有被预处理影响，虽然它们都包含SIZE。
```
* **一个宏定义的作用范围通常到出现这个宏的文件末尾。** 由于宏是预处理器处理的，它们不遵从通常的范围规则。一个定义在函数中的宏不是仅在函数内起作用，而是作用到文件末尾。
* **宏定义可以被定义两遍。** 小的间隔上的差异是允许的，但是宏的替换列表（和参数，如果有的话）中的记号都必须一致。
* **宏可以使用#undef指令”取消定义“。** #undef指令有如下形式：
```sh
[#undef指令]   #undef   标识符
其中标识符是一个宏名。例如，指令
#undef N
会删除宏N当前的定义。（如果N没有被定义成一个宏，#undef指令没有任何意义。）#undef指令的一个用途是取消一个宏的现有定义，以便重新给出新的定义。
```
## 宏定义中的圆括号
对于在一个宏定义中哪里要加圆括号有两条规则要遵守。
* 首先，如果宏的替换列表中有运算符，那么始终要将替换列表放在括号中：#define TWO_PI (2 * 3.14159)。
* 其次，如果宏有参数，每次参数在替换列表中出现时都要放在圆括号中：#define SCALE(x) ((x) * 10）  没有括号的话，我们将无法确保编译器会将替换列表和参数作为完整的表达式。
```sh
为了展示为替换列表添加圆括号的重要性，考虑下面的宏定义，其中的替换列表没有添加圆括号：
  #define TWO_PI 2 * 3.14159
  /* 需要给替换列表加圆括号*/
在预处理时，语句
  conversion_factor = 360 / TWO_PI;
变为
  conversion_factor = 360 / 2 * 3.14159;
除法会在乘法之前执行，产生的结果并不是期望的结果。

```
```sh
当宏有参数时，仅给替换列表添加圆括号是不够的。参数的每一次出现都要添加圆括号。
例如，假设SCALE定义如下：
  #define SCALE(x) (x * 10)  /* 需要给x添加括号 */
在预处理过程中，语句
  j = SCALE(i + 1);
变为
  j = (i + 1 * 10);
由于乘法的优先级比加法高，这条语句等价于
  j = i + 10;
而不是我们希望的 j = (i + 1) * 10;
```

## 创建较长的宏
在创建较长的宏时，逗号运用符会十分有用。特别是用逗号运算符来使替换列表包含一系列表达式。例如，下面的宏会读入一个字符串，再把字符串显示出来：
  #define ECHO(s) (get(s), puts(s))
gets函数和puts函数的调用都是表达式，因此使用逗号运算符链接它们是合法的。我们甚至可以吧ECHO宏当作一个函数来使用：
  ECHO(str);/*替换为(gets(str), puts(str));*/
    除了使用逗号运算符，我们也许还可以将gets函数和puts函数的调用放在大括号中形成符合语句：
    #define ECHO(s) { gets(s); puts(s);}
  遗憾的是，这种方式并不奏效。假如我们将ECHO宏用于下面的if语句：
    if(echo_flag)
      ECHO(str);
    else
      gets(str);
  将ECHO宏替换到下面的结果：
    if(echo_flag)
      { gets(str); puts(str); };
    else
      gets(str);
  编译器会将两头作为完整的if语句：
    if(echo_flag)
      { gets(str); puts(str); };
  编译器会将跟在后面的分号作为空语句，并对else字句产生错误信息，因为它不属于任何if语句。

